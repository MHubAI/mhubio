"""
-------------------------------------------------
MHub - MHA Conversion Module
-------------------------------------------------

-------------------------------------------------
Author: Leonard NÃ¼rnberg
Email:  leonard.nuernberg@maastrichtuniversity.nl
-------------------------------------------------
"""

from enum import Enum
from typing import  Dict, Any

from mhubio.core import Module, Instance, InstanceDataCollection, InstanceData, FileType
from mhubio.core.IO import IO

import os
import os, SimpleITK as sitk
from pathlib import Path

# conversion dependencies (engine = plastimatch)
import pyplastimatch as pypla # type: ignore

# conversion dependencies (engine = panimg)
from panimg.image_builders.dicom import image_builder_dicom # type: ignore
from panimg.image_builders.metaio_nrrd import image_builder_nrrd # type: ignore
from panimg.image_builders.metaio_nifti import image_builder_nifti # type: ignore

class MhaConverterEngine(Enum):
    PLASTIMATCH = 'plastimatch'
    PANIMG      = 'panimg'

@IO.Config('engine', MhaConverterEngine, 'plastimatch', factory=MhaConverterEngine, the='engine to use for conversion')
@IO.ConfigInput('in_datas', 'dicom|nrrd|nifti', the="target data that will be converted to mha")
@IO.Config('allow_multi_input', bool, False, the='allow multiple input files')
@IO.Config('bundle_name', str, 'mha', the="bundle name converted data will be added to")
@IO.Config('converted_file_name', str, '[filename].mha', the='name of the converted file')
@IO.Config('overwrite_existing_file', bool, False, the='overwrite existing file if it exists')
class MhaConverter(Module):
    """
    Conversion module that converts DICOM, NRRD and NIFTI data into MHA (using plastimatch).
    """

    engine: MhaConverterEngine
    allow_multi_input: bool
    bundle_name: str                    # TODO optional type declaration
    converted_file_name: str
    overwrite_existing_file: bool

    def plastimatch(self, instance: Instance, in_data: InstanceData, out_data: InstanceData, log_data: InstanceData) -> None:

        #print("[DRY RUN] plastimatch")
        #print("[DRY RUN] in:  ", in_data.abspath)
        #print("[DRY RUN] out: ", out_data.abspath)
        #print("[DRY RUN] log: ", log_data.abspath)
        #return

        # set input and output paths later passed to plastimatch
        convert_args_ct: Dict[str, Any] = {
            "input" : in_data.abspath,
            "output-img" : out_data.abspath
        }

        # remove old log file if it exist
        if os.path.isfile(log_data.abspath): 
            os.remove(log_data.abspath)
        
        # run conversion using plastimatch
        pypla.convert(
            verbose=self.config.verbose,
            path_to_log_file=log_data.abspath,
            **convert_args_ct
        )

        if os.path.isfile(log_data.abspath):
            log_data.confirm()

    def panimg(self, instance: Instance, in_data: InstanceData, out_data: InstanceData) -> None:

        # check datatype 
        if in_data.type.ftype == FileType.DICOM:

            # extract dicom files
            # TODO: check if panimg can accept a dicom folder instad
            dcm_files_abspaths = [Path(os.path.join(in_data.abspath, f)) for f in os.listdir(in_data.abspath) if f.endswith(".dcm")]

            # for dicom data use a dicom image builder
            #  as we control the input (one dicom instance) we expect exactly one output. 
            #  We set None as default to avoid StopIteration exceptions in caseof an empty iterator.
            sitk_image = next(image_builder_dicom(files=dcm_files_abspaths), None)
            
        elif in_data.type.ftype == FileType.NRRD:

            # for nrrd files use the nrrd image builder
            sitk_image = next(image_builder_nrrd(files=[Path(in_data.abspath)]), None)

        elif in_data.type.ftype == FileType.NIFTI:

            # for nifti files use the tiff image builder
            sitk_image = next(image_builder_nifti(files=[Path(in_data.abspath)]), None)

        else:
            print("CONVERT ERROR: unsupported file type: ", in_data.type.ftype)
            return

        # check that we got an image
        if sitk_image is None:
            print("CONVERT ERROR: image builder returned no images.")
            return

        # write the file via SimpleITK
        sitk.WriteImage(sitk_image.image, out_data.abspath)

    @IO.Instance()
    @IO.Inputs('in_datas', the="data to be converted")
    @IO.Outputs('out_datas', path=IO.C('converted_file_name'), dtype='mha', data='in_datas', bundle=IO.C('bundle_name'), auto_increment=True, the="converted data")
    @IO.Outputs('log_datas', path='[basename].pmconv.log', dtype='log:log-task=conversion', data='in_datas', bundle=IO.C('bundle_name'), auto_increment=True, the="log generated by conversion engine")
    def task(self, instance: Instance, in_datas: InstanceDataCollection, out_datas: InstanceDataCollection, log_datas: InstanceDataCollection, **kwargs) -> None:

        # some sanity checks
        assert isinstance(in_datas, InstanceDataCollection)
        assert isinstance(out_datas, InstanceDataCollection)
        assert len(in_datas) == len(out_datas)
        assert len(in_datas) == len(log_datas)

        # display the engine used
        print(f"MHA conversion using engine: {self.engine}")

        # filtered collection must not be empty
        if len(in_datas) == 0:
            print(f"CONVERT ERROR: no data found in instance {str(instance)}.")
            return None

        # check if multi file conversion is enables
        if not self.allow_multi_input and len(in_datas) > 1:
            print("WARNING: found more than one matching file but multi file conversion is disabled. Only the first file will be converted.")
            in_datas = InstanceDataCollection([in_datas.first()])

        # conversion step
        for i, in_data in enumerate(in_datas):
            out_data = out_datas.get(i)
            log_data = log_datas.get(i)

            # check if output data already exists
            if os.path.isfile(out_data.abspath) and not self.overwrite_existing_file:
                print("CONVERT ERROR: File already exists: ", out_data.abspath)
                continue

            # check supported datatype (both engines support dicom, nrrd and nifti)
            if in_data.type.ftype not in [FileType.DICOM, FileType.NRRD, FileType.NIFTI]:
                raise ValueError(f"CONVERT ERROR: unsupported file type {in_data.type.ftype}.")
            
            # pass to conversion engine
            if self.engine == MhaConverterEngine.PLASTIMATCH:
                self.plastimatch(instance, in_data, out_data, log_data)

            elif self.engine == MhaConverterEngine.PANIMG:
                self.panimg(instance, in_data, out_data)

            else:
                raise ValueError(f"CONVERT ERROR: unknown engine {self.engine}.")